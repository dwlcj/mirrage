#version 450
#extension GL_ARB_separate_shader_objects : enable


layout (constant_id = 0) const int HISTOGRAM_SLOTS = 256;
layout (constant_id = 2) const float HISTOGRAM_MIN = -10;
layout (constant_id = 3) const float HISTOGRAM_MAX = 10;

layout (local_size_x = 128, local_size_y = 1, local_size_z = 1 ) in;

layout(set=1, binding = 1) buffer Data {
	uint histogram[HISTOGRAM_SLOTS + 1];
};

layout(push_constant) uniform Push_constants {
	// min/max log display luminance
	vec4 parameters;
} pcs;

shared uint local_histogram[HISTOGRAM_SLOTS];
shared int total;
shared int trimmings;

#include "tone_mapping_prefix_sum.glsl"


float delta_L_t(float La) {
	// Table 1 of "A Visibility Matching Tone Reproduction Operator for High Dynamic Range Scenes"
	float x = log(La)/log(10)+1; // to log_10

	if     (x < -3.94)   return -2.86;
	else if(x < -1.44)   return pow(0.405*x+1.6, 2.18) - 2.86;
	else if(x < -0.0184) return x - 0.395;
	else if(x < 1.9)     return pow(0.249*x+0.65, 2.7) - 0.72;
	else                 return x - 1.255;
}

float index_to_log_lum(uint index) {
	return float(index)/HISTOGRAM_SLOTS * (HISTOGRAM_MAX-HISTOGRAM_MIN) + HISTOGRAM_MIN;
}

void main() {
	float DISPLAY_MIN = pcs.parameters.x;
	float DISPLAY_MAX = pcs.parameters.y;

	// calculate constants and initialize shared memory
	uint local_id = gl_LocalInvocationID.x + gl_LocalInvocationID.y*gl_WorkGroupSize.x;
	uint local_size = gl_WorkGroupSize.x * gl_WorkGroupSize.y;

	float world_range = HISTOGRAM_MAX - HISTOGRAM_MIN;
	float display_range = DISPLAY_MAX - DISPLAY_MIN;
	float bin_width = world_range / HISTOGRAM_SLOTS;

	total = 0;
	trimmings = 0;

	memoryBarrierShared();
	barrier();


	// copy histogram to shared memory and sum up total
	int sub_total = 0;
	for(uint i=local_id; i<HISTOGRAM_SLOTS; i+=local_size) {
		local_histogram[i] = histogram[i];
		sub_total += int(local_histogram[i]);
	}
	atomicAdd(total, sub_total);

	memoryBarrierShared();
	barrier();


	// trim histogram
	float tolerance = 0.0001 * total;
	int safe_guard = 0;
	while(total>=tolerance && safe_guard++<100) {
		build_prefix_sum();
		float sum = prefix_sum[HISTOGRAM_SLOTS];
		int sub_trimmings = 0;

		// trim each bucket
		for(uint i=local_id; i<HISTOGRAM_SLOTS; i+=local_size) {
			float L_w = exp(index_to_log_lum(i));
			float L_d = exp(DISPLAY_MIN + display_range * float(prefix_sum[i])/sum);
			int ceiling = int(floor(delta_L_t(L_d)/delta_L_t(L_w) * total*bin_width*L_w / (display_range*L_d)));

			if(local_histogram[i] >= ceiling) {
				sub_trimmings += int(local_histogram[i]) - ceiling;
				local_histogram[i] = uint(ceiling);
			}
		}

		// update total and sum sub-trimmings to check if we are done
		memoryBarrierShared();
		barrier();

		atomicAdd(total, -sub_trimmings);
		atomicAdd(trimmings, sub_trimmings);

		memoryBarrierShared();
		barrier();

		if(trimmings < tolerance)
			break;

		trimmings = 0;
	}

	if(total<tolerance) {
		for(uint i=local_id; i<HISTOGRAM_SLOTS; i+=local_size) {
			local_histogram[i] = 0;
		}
		memoryBarrierShared();
		barrier();
	}

	// write result back to global memory
	for(uint i=local_id; i<HISTOGRAM_SLOTS; i+=local_size) {
		histogram[i] = local_histogram[i];
	}
}
